{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"posts":[{"title":"基于计算机视觉的物体尺寸测量方法的研究和实现","date":"2020-05-09T01:45:42.000Z","path":"2020/05/09/Data-Structure/","content":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h2><blockquote>\n<p>&#8195;&#8195;这篇文章是对我的毕业论文核心内容的一次总结，省略了论文里不重要的东西，只保留了最核心的部分。</p>\n</blockquote>\n<h2 id=\"2-摘要\"><a href=\"#2-摘要\" class=\"headerlink\" title=\"2.摘要\"></a>2.摘要</h2><blockquote>\n<p>&#8195;&#8195;本文介绍了对静态图片中的物体进行尺寸测量的方法，处理的静态图片是来自于摄像头在一定条件下拍摄的，在特定的情况下（不同的检测方法有不同的拍摄要求）对待测物体进行拍摄，输入到电脑端，利用Python和OpenCV对收集的图像进行一系列处理。首先是对图片进行预处理，包括将图像中的特征点灰度化、去除图像噪声、通过图像特征点的提取、提取图片中固定的区域、对需要提取的其他区域再做处理，例如填充区域，膨胀，开操作等。然后编写轮廓检测算法检测图片中物体的外轮廓，最后在边界框的图像上绘制出一个边界框的顶点和轮廓，通过边界框计算顶点和轮廓的四个顶点的坐标，可以初步地计算一个物体的大小和尺寸。</p>\n</blockquote>\n<h2 id=\"3-测量原理\"><a href=\"#3-测量原理\" class=\"headerlink\" title=\"3.测量原理\"></a>3.测量原理</h2><blockquote>\n<p>&#8195;&#8195;本文测量原理有两个，一是根据小孔成像（透镜成像）和三角形相似原理，二是根据参考物的尺寸信息对物体进行测量。根据参考物的尺寸信息对物体进行测量的这种方法比较通用，也相对比较简单。我们只要事先确定参考物的位置及参考物的尺寸信息即可，这里的参考物一般只有一个并且它的尺寸和形状尽量要规则（一元硬币就是一个不错的参考物），如下图是一个参考物示例。</p>\n</blockquote>\n<p>&#8195;&#8195;&#8195;&#8195;<img src=\"/2020/05/09/Data-Structure/3.1.png\" alt=\"参考物示例\" title=\" 参考物示例\"></p>\n<blockquote>\n<p>&#8195;&#8195;通过参考物的实际尺寸和它在图像上的成像尺寸，可以确定像素和实际尺寸的比例，这样很快能测量出待测物体的尺寸信息。根据小孔成像原理做起来就有些复杂了，如上图所示是小孔成像的原理。因为根据对于小孔成像原理来说，不管我们在采集物体图片信息用的是何种相机，也不管我们利用USB摄像头拍照还是手机拍照，当物体离我们拍摄的镜头较远的时候，它们的成像原理都是：当物距大于二倍焦距时，所成的像是倒立、缩小的实像。如下图，再根据三角形的相似公式，有△ABO∽△A’B’O，可以推出AB/A’B’=BO/B’O。即知道AB，u，v，A’B’中任意三个数的值，就能求出第4个数的值。</p>\n</blockquote>\n<p><img src=\"/2020/05/09/Data-Structure/%E9%80%8F%E9%95%9C%E6%88%90%E5%83%8F.png\" alt=\"参考物示例\" title=\" 透镜成像原理\"></p>\n<blockquote>\n<p>&#8195;&#8195;其中，假设AB是实物，u是该物体到镜头的距离，A’B’是物体的成像，v是物体的成像到镜头的距离。通过在纸上画一条10cm到20cm的线段，固定拍摄距离为30cm进行拍摄后，再测量出该线段在图像上的物理尺寸，这样就能求出上文所说的v的值（该值是在固定了拍摄距离即镜头离物体30cm处求得的，也可以改变拍摄距离来求得不同的v值）。在v值已知后，同样也可以根据物体在图像中所占的像素，求出在固定距离下，像素与实际物理尺寸之间的比率。该比率也是随着拍摄距离的改变而发生变化。</p>\n</blockquote>\n<h2 id=\"4-测量准备\"><a href=\"#4-测量准备\" class=\"headerlink\" title=\"4.测量准备\"></a>4.测量准备</h2><blockquote>\n<p>&#8195;&#8195;系统测量的对象主要是规则物体，如方形盒装物体等。该系统能识别对象物体的外轮廓，并能根据物体的外轮阔计算出物体的面积和体积，要求尽量减少识别和计算过程中造成的不可避免的数据误差，能最大程度上还原物体的真实三维信息。需要提前说明的是，本文在用USB摄像头拍摄物体的过程中，提前将物体与摄像头之间的距离设定为30厘米且固定不变，采取垂直拍摄即摄像头镜面与物体表面保持。这样可以避免做相机标定操作和减少在测量和计算摄像头焦距时的误差，还有一个好处是能使拍摄的图片更好地被计算机处理。测量流程图如下：<br>&#8195;&#8195;</p>\n</blockquote>\n<p><img src=\"/2020/05/09/Data-Structure/%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png\" alt=\"参考物示例\" title=\" 整体流程\"></p>\n<h2 id=\"5-系统设计\"><a href=\"#5-系统设计\" class=\"headerlink\" title=\"5.系统设计\"></a>5.系统设计</h2><blockquote>\n<p>&#8195;&#8195;程序开始，首先输入图像，再进行图像预处理，对图像进行高斯滤波，去除噪声。执行边缘检测，然后执行膨胀、腐蚀，来闭合边缘之间的间隙。用Python和Opencv提供的CV库编写轮廓检测算法，判断图像中是否存在轮廓，保留水平方向的终点坐标，例如对于轮廓为矩形的物体，只需四个顶点来保存轮廓信息。然后选择本文使用的两种方法计算轮廓的真实物理尺寸并在图像上显示检测结果和测量效果。至此，最终的测量结果显示在电脑屏幕上，关闭窗口，则程序结束。整个程序流程介绍完毕。系统流程图如下图所示。</p>\n</blockquote>\n<p><img src=\"/2020/05/09/Data-Structure/%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE.png\" alt=\"程序流程图\" title=\"程序流程图\"></p>\n<blockquote>\n<p>&#8195;&#8195;该系统硬件部分是一个USB摄像头，软件部分包括四个大的模块，分别是图像采集、图像预处理、识别与测量、结果输出模块。图像采集是使用USB摄像头实时拍摄的图片，通过USB摄像头拍照再将拍摄到的图片保存在计算机本地文件下，再通过编程从本地文件中读取之前采集并保存的图片，进行预处理操作。图像预处理模块的功能主要是对采集的图片进行分析和处理，包括滤波、二值化、图像分割等一系列预处理的操作，以便后续测量工作。编写代码对预处理的图片进行测量后，再输出测量结果显示在电脑屏幕上。该系统的整体框架图如下图所示。</p>\n</blockquote>\n<p><img src=\"/2020/05/09/Data-Structure/%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6%E5%9B%BE.png\" alt=\"系统框架图\" title=\"系统框架图\"></p>\n<h2 id=\"6-开发及运行环境\"><a href=\"#6-开发及运行环境\" class=\"headerlink\" title=\"6.开发及运行环境\"></a>6.开发及运行环境</h2><blockquote>\n<p>&#8195;&#8195;该是系统通过Python+OpenCV在Windows 10操作系统下借助Spyder3编辑器实现的，包括硬件平台和软件平台，其中硬件平台和软件平台还有其他设备的主要参数如下：</p>\n</blockquote>\n<blockquote>\n<p>1.硬件平台</p>\n<ul>\n<li>CPU：Core i5-6300HQ 2.3GHz</li>\n<li>硬盘：100G以上</li>\n<li>运行内存：4G以上</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>2.软件平台</p>\n<ul>\n<li>操作系统：Windows10</li>\n<li>Python版本：Python 3.7.0</li>\n<li>OpenCV版本：OpenCV-Python 3.4.5</li>\n<li>Python IDE：Spyder 3.3.3</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>3.其他设备<br>&#8195;&#8195;图像采集部分需要用计算机连接一个USB摄像头，本系统使用的USB摄像头的主要参数如下：</p>\n<ul>\n<li>感光元件：CMOS</li>\n<li>摄像头像素：1200万</li>\n<li>分辨率：1600×1200</li>\n<li>镜头描述：五玻镜头</li>\n<li>接口类型：USB2.0</li>\n<li>最大帧频：30FPS</li>\n</ul>\n</blockquote>\n<h2 id=\"7-实验结果\"><a href=\"#7-实验结果\" class=\"headerlink\" title=\"7.实验结果\"></a>7.实验结果</h2><blockquote>\n<p>&#8195;&#8195;使用上文所述的两种方法，对静态图片中的物体进行尺寸检测，最终的检测结果有不同效果，虽然两种对物体的检测方法在实际检测过程中存在一定误差，但是最终的检测效果还是有一定价值的。其中，利用寻找参考物的方法的检测结果误差较小，利用相机透镜成像原理的检测结果相比之下误差较大。在相机透镜成像原理之上用摄像头实时拍摄的检测效果也存在一定误差。利用参考物的测量方法的测试图如下面这些图所示。</p>\n</blockquote>\n<p><img src=\"/2020/05/09/Data-Structure/%E5%9B%BE1.png\" alt=\"测试图1\" title=\"测试图1\"><br><img src=\"/2020/05/09/Data-Structure/%E5%9B%BE2.png\" alt=\"测试图1\" title=\"测试图1的测量结果\"><br><font color=\"#0099ff\" size=\"4\">注：以原图中的硬币作为参考物，其实际直径为25mm，原图的矩形实际的长和宽均为69mm。<br>检测结果为宽68.4mm，长69.0mm。</font></p>\n<p><img src=\"/2020/05/09/Data-Structure/%E5%9B%BE3.png\" alt=\"系统框架图\" title=\"测试图2\"><br><img src=\"/2020/05/09/Data-Structure/%E5%9B%BE4.png\" alt=\"系统框架图\" title=\"测试图2的测量结果\"><br><font color=\"#0099ff\" size=\"4\">注：以原图中的硬币作为参考物，其实际直径为25mm，原校园卡实际长为85mm,宽为54mm。<br>检测结果为长84.3mm，宽53.6mm。</font></p>\n<blockquote>\n<p>&#8195;&#8195;利用小孔成像原理，即无参考物的测量方法，对一元硬币和和校园卡进行测量，它们的测试图和对应的检测结果分别如下图所示。</p>\n</blockquote>\n<p>&#8195;&#8195;&#8195;&#8195;&#8195;&#8195;&#8195;<img src=\"/2020/05/09/Data-Structure/%E5%9B%BE5.png\" alt=\"系统框架图\" title=\"测试图3\"><br>&#8195;&#8195;&#8195;&#8195;<img src=\"/2020/05/09/Data-Structure/%E5%9B%BE6.png\" alt=\"系统框架图\" title=\"测试图3的测量结果\"><br><font color=\"#0099ff\" size=\"4\">注：硬币的实际直径为25mm。<br>检测结果为宽22.9mm。<br>校园卡实际长为85mm，宽为54mm。<br>检测结果为长82.9mm，宽57.1mm。</font></p>\n<h2 id=\"8-实验误差分析\"><a href=\"#8-实验误差分析\" class=\"headerlink\" title=\"8.实验误差分析\"></a>8.实验误差分析</h2><blockquote>\n<p>&#8195;&#8195;根据本文在第二章所介绍的两种测量方法，编写相关程序在对部分规则物体进行测量后，得出的测量结果基本上是正确的，然而这两种测量方法的准确性有一定的差别。根据绝对误差和相对误差来度量测量结果的准确性，在这里，绝对误差的值是测量值与真实值做差的绝对值，相对误差是绝对误差与真实值的比值。利用小孔成像原理，即无参考物的测量方法去测量手绘矩形、校园卡和一元硬币，其误差分析表如下所示：</p>\n</blockquote>\n<p><img src=\"/2020/05/09/Data-Structure/%E8%A1%A81.png\" alt=\"误差分析表1\" title=\"误差分析表1\"></p>\n<blockquote>\n<p>&#8195;&#8195;有参考物(参考物为一元硬币，其直径为25mm)的测量方法，主要测量了手绘矩形和校园卡，测量的误差相对无参考物的误差要小，其误差分析表如下所示：</p>\n</blockquote>\n<p><img src=\"/2020/05/09/Data-Structure/%E8%A1%A82.png\" alt=\"误差分析表2\" title=\"误差分析表2\"></p>\n<h2 id=\"9-总结与展望\"><a href=\"#9-总结与展望\" class=\"headerlink\" title=\"9.总结与展望\"></a>9.总结与展望</h2><blockquote>\n<p>&#8195;&#8195;本文介绍的这两种方法都是对静态图片，即摄像头拍摄或者手机拍摄的图片中的目标物体进行尺寸检测。在检测之前，由于需要先对图片进行预处理，所以对拍摄的图片有一些要求，图片中的物体是近似二维的，平面的图像并且图像中的物体轮廓尽量要明显。<br>该系统测量的对象主要是规则物体，如方形盒装物体等。该系统能识别对象物体的外轮廓，并能根据物体的外轮阔计算出物体的面积和体积，要求尽量减少识别和计算过程中造成的不可避免的数据误差，能最大程度上还原物体的真实三维信息。该系统硬件部分是一个USB摄像头，软件部分包括四个大的模块，分别是图像采集、图像预处理、识别与测量、结果输出模块。图像采集是使用USB摄像头实时拍摄的图片，图像预处理即对采集的图片进行分析和处理，以便后续测量工作。编写代码对预处理的图片进行测量后，再输出测量结果显示在电脑屏幕上。程序开始，首先输入图像，再对图像进行一系列相关的图像预处理。然后对图像进行边缘检测，然后执行膨胀、腐蚀，来闭合边缘之间的间隙。用Python和Opencv提供的CV库编写轮廓检测算法，这一步在图像预处理之后，判断图像中是否存在轮廓，存在就压缩各个方向的元素，只保留这些方向的终点坐标，例如对于轮廓为矩形的物体，只需四个顶点来保存轮廓信息。然后选择本文使用的两种方法计算轮廓的真实物理尺寸并在图像上显示检测结果和测量效果。<br>&#8195;&#8195;最后的实验结果表明，利用参考物的方法和利用相机透镜成像原理的方法都存在其优点和缺点，以下对这两种方法的优点和缺点进行总结。利用图片中的参考物方法的优点：（1）不需要控制拍摄设备离拍摄物体的距离。（2）不需要限定拍摄设备。缺点：（1）需要找一个合适的参考物。（2）需要给出参考物的真实物理尺寸。利用相机的透镜成像原理的优点：相比上一种方法，不需要参考物，即不需要先测量参考物的尺寸，也不需要将参考物和待测物体放在一起拍摄。缺点：（1）每使用不同的拍摄设备，都要先对拍摄设备的焦距进行多次测量。（2）需要先固定拍摄距离，不同的拍摄距离有不同的成像效果。总之，这两种方法各有优缺点，若能解决第二种方法对拍摄距离的限制，那么实时拍摄物体，在离物体不同的距离下，对物体尺寸的检测应该能有更好的效果。但是要从平面的、二维的图像中获取物体的3D空间几何信息还是非常困难，可以利用双目视觉和三维视觉来尝试解决这个问题，未来在这一方向还有待发展和研究。</p>\n</blockquote>\n","permalink":"http://yoursite.com/2020/05/09/Data-Structure/","categories":[],"tags":[{"name":"本科毕业设计","slug":"本科毕业设计","permalink":"http://yoursite.com/tags/本科毕业设计/"}]},{"title":"基于隐马尔科夫模型的分词任务","date":"2019-06-03T15:12:45.000Z","path":"2019/06/03/HMM/","content":"<h2 id=\"模型的定义\"><a href=\"#模型的定义\" class=\"headerlink\" title=\"模型的定义\"></a>模型的定义</h2><p>&#8195;&#8195;HMM（Hidden Markov Model）是一种关于时序的概率图模型，是由一个隐藏的不可观测的状态随机序列，再由各个状态生成一个观测值而产生观测随机序列的过程。隐藏的状态序列称为状态序列（state sequence），生成的观测随机序列称为观测序列（observation sequence）。下面是隐马尔可夫模型的图结构：<br><img src=\"/2019/06/03/HMM/HMM.jpg\" alt=\"image\"></p>\n<p>&#8195;&#8195;其中，[y1, y2 …. yi, yn] 是状态序列，[x1, x2 …. xi, xn]是观测序列，yi 表示在 i 时刻的状态值， xi 表示在 i 时刻的观测值。</p>\n<h2 id=\"五元组，三类问题，三个假设\"><a href=\"#五元组，三类问题，三个假设\" class=\"headerlink\" title=\"五元组，三类问题，三个假设\"></a>五元组，三类问题，三个假设</h2><p><font color=\"#0099ff\" size=\"4\">要确定一个HMM模型，我们需要知道这个五元组:</font></p>\n<blockquote>\n<p>StatusSet:      状态值集合<br>ObservedSet:    观察值集合<br>TransProbMatrix:转移概率矩阵<br>EmitProbMatrix: 发射概率矩阵<br>InitStatus:     初始状态分布</p>\n</blockquote>\n<p><font color=\"#0099ff\" size=\"4\">当通过五元组中某些已知条件来求未知时，就得到HMM的三类问题：</font></p>\n<blockquote>\n<p>（1）参数(StatusSet,TransProbMatrix,EmitRobMatrix,InitStatus)已知的情况下，求解观察值序列。(Forward-backward算法)<br>（2）参数(ObservedSet,TransProbMatrix,EmitRobMatrix,InitStatus)已知的情况下，求解状态值序列。(viterbi算法)<br>（3）参数(ObservedSet)已知的情况下，求解(TransProbMatrix,   EmitRobMatrix,InitStatus)。(Baum-Welch算法) </p>\n</blockquote>\n<p>其中，第三种问题最玄乎也最不常用，第二种问题最常用，【中文分词】，【语音识别】, 【新词发现】，【词性标注】都有它的一席之地。中文分词这个例子属于第二个问题，即解码问题。</p>\n<p><font color=\"#0099ff\" size=\"4\">HMM模型的三个基本假设如下： </font></p>\n<blockquote>\n<p>（1）有限历史性假设（S[i] 只由S[i-1]决定）:<br>P(Status[i]|Status[i-1],Status[i-2],…Status[1]) =         P(Status[i]|Status[i-1])<br>（2）齐次性假设(状态和当前时刻无关):<br>P(Status[i]|Status[i-1]) = P(Status[j]|Status[j-1])<br>（3）观察值独立性假设(观察值只取决于当前状态值):<br>P(Observed[i]|Status[i],Status[i-1],…,Status[1]) =         P(Observed[i]|Status[i])<br>从网络图中看的话，即，xi 只与 yi 有关， yi 只与 y(i-1)有关。</p>\n</blockquote>\n<p><font color=\"#0099ff\" size=\"4\">确定一个HMM模型，我们需要知道以下信息:</font></p>\n<blockquote>\n<p>(1)首先我们得知道，yi 和 xi 都能取什么样的值，也就是状态集合和观测值集合。<br>(2)有了状态集合，我们回到假设1，任意时刻的状态只依赖前一时刻的状态，那我们需要知道每个状态之间的转换概率，这个概率就被称为状态转移概率。<br>(3)状态之间的转移概率有了，我们还需要知道模型在初始时刻各状态出现的概率，就是所谓的初始状态概率。<br>(4)回到假设2，任意时刻的观测值，只与该时刻的状态值有关，那么我们要知道，在一个状态下，所对应的各个观测值的概率，就是所谓的观测概率（也称发射概率）。</p>\n</blockquote>\n<h2 id=\"中文分词\"><a href=\"#中文分词\" class=\"headerlink\" title=\"中文分词\"></a>中文分词</h2><p>&#8195;&#8195;把分词这个场景用HMM建模，我们可以初步认为，句中每个字（观测值Observed）有一个对应的状态（状态值Status），状态值集合（StatusSet）我们用(B, M, E, S): {B:begin, M:middle, E:end, S:single}表示:</p>\n<blockquote>\n<p>B：一个词的开始<br>E：一个词的结束<br>M：一个词的中间<br>S：单字成词</p>\n</blockquote>\n<p><font color=\"red\" size=\"3\">&#8195;&#8195;可以发现一个规律：B后面只可能接(M or E)，不可能接(B or S)。而M后面也只可能接(M or E)，不可能接(B, S)。</font></p>\n<p>&#8195;&#8195;观察值集合（ObservedSet）为就是所有汉字(一二三四五六七八九十……)，甚至包括标点符号所组成的集合。例如：  </p>\n<blockquote>\n<p>S B E B E S B E B E B E<br>我本科毕业于湖北科技学院</p>\n</blockquote>\n<p>&#8195;&#8195;我们可以根据这句话的状态序列将句子切分为：</p>\n<blockquote>\n<p>我/本科/毕业/于/湖北/科技/学院</p>\n</blockquote>\n<p><font color=\"#0066ff\" size=\"4\">&#8195;&#8195;在此处，我们已经将分词的问题，转换为求状态序列的问题。可以把分词的问题，转化成为：已知ObservedSet, TransProbMatrix，EmitProbMatrix，InitStatus ，求状态值序列 （StatusSet）。</font></p>\n","permalink":"http://yoursite.com/2019/06/03/HMM/","categories":[],"tags":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://yoursite.com/tags/自然语言处理/"}]}]}